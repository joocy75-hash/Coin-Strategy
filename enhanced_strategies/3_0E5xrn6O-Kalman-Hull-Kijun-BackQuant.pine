/////////////////////////////////////////////////////////////// © BackQuant ///////////////////////////////////////////////////////////////
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © BackQuant
//@version=6

indicator('Kalman Hull Kijun [BackQuant]', overlay = true)

// Define Constants
const string calc = "Kijun Sen Base Settings"
const string kcalc = "Kalman Hull Settings"
const string ui   = "Plotting and UI Settings"

// Define User Inputs
// Kijun Sen Base Settings
int basePeriod = input.int(26, "Kijun Base Period", group = calc)

// Kalman Hull Settings
float pricesource = input.source(close, "Kalman Price Source", group = kcalc)
float measurementNoise = input.float(3.0, title="Measurement Noise", group = kcalc, tooltip = "Lookback Period/ Calculation Length", step = 1.0)
float processNoise = input.float(0.01, title="Process Noise", step = 0.01, group = kcalc)

// Plotting and UI Settings
bool showKijun = input.bool(true, "Show Kijun on Chart?", group = ui)
bool showFill = input.bool(true, "Show Gradient Fill", group = ui)
int lineW = input.int(3, "Line Width", group = ui)
bool paintCandles = input.bool(true, "Paint candles according to Trend?", group = ui)
color longColor  = input.color(#00ff00, "Long Color", group = ui, inline = "Col")
color shortColor = input.color(#ff0000, "Short Color", group = ui, inline = "Col")

/////////////////////////////////////////////////////////////// © BackQuant ///////////////////////////////////////////////////////////////
// Kalman Price Filter Function
N = 5
var float[] stateEstimate = array.new_float(N, na)
var float[] errorCovariance = array.new_float(N, 100.0)
f_init(series float pricesource) =>
    if na(array.get(stateEstimate, 0))
        for i = 0 to N-1
            array.set(stateEstimate, i, pricesource)
            array.set(errorCovariance, i, 1.0)

f_kalman(series float pricesource, float measurementNoise) =>
    // Prediction Step
    predictedStateEstimate = array.new_float(N)
    predictedErrorCovariance = array.new_float(N)
    for i = 0 to N-1
        array.set(predictedStateEstimate, i, array.get(stateEstimate, i)) // Simplified prediction
        array.set(predictedErrorCovariance, i, array.get(errorCovariance, i) + processNoise)
    
    kalmanGain = array.new_float(N)
    for i = 0 to N-1
        kg = array.get(predictedErrorCovariance, i) / (array.get(predictedErrorCovariance, i) + measurementNoise)
        array.set(kalmanGain, i, kg)
        array.set(stateEstimate, i, array.get(predictedStateEstimate, i) + kg * (pricesource - array.get(predictedStateEstimate, i)))
        array.set(errorCovariance, i, (1 - kg) * array.get(predictedErrorCovariance, i))
    
    array.get(stateEstimate, 0)
/////////////////////////////////////////////////////////////// © BackQuant ///////////////////////////////////////////////////////////////
// Hull Moving Average Function with Kalman instead of Weighted Moving Average
KHMA(_src, _length) =>
    f_kalman(2 * f_kalman(_src, _length / 2) - f_kalman(_src, _length), math.round(math.sqrt(_length)))
// Donchian Function
donchian(float src, int len) =>
    math.avg(
         ta.lowest(src,len), 
         ta.highest(src,len)
         )  

// Call Functions
f_init(pricesource)
kalmanFilteredPrice = f_kalman(pricesource, measurementNoise)
kalmanHMA = KHMA(pricesource, measurementNoise)
base = donchian(kalmanHMA,basePeriod)

// Signal Conditions
long = pricesource>base
short = pricesource<base

// Plotting 
col = long?longColor:short?shortColor:color.white

// Main line (kijun)
pBase = plot(base, color = col, title = "Kalman Hull Kijun", linewidth = lineW,
     display = showKijun ? display.all : display.none)

// Hidden price plot just for fills
pPx = plot(showFill?close:na, title="Price (hidden)", display=display.none)

fill(pPx, pBase,
     close > base ? close : base,
     close > base ? base  : close,
     close > base ? color.new(longColor, 10)  : na,
     close > base ? color.new(longColor, 85)  : na,
     title="Up Energy")

fill(pPx, pBase,
     close < base ? base  : close,
     close < base ? close : base,
     close < base ? color.new(shortColor, 10) : na,
     close < base ? color.new(shortColor, 85) : na,
     title="Down Energy")

float rim = ta.atr(14) * 0.08

pRimUp = plot(close - rim, display=display.none)
pRimDn = plot(close + rim, display=display.none)

// only show the rim on the active side
fill(pPx, pRimUp, close > base ? color.new(longColor, 35) : na, title="Up Rim")
fill(pPx, pRimDn, close < base ? color.new(shortColor, 35) : na, title="Down Rim")

// Color Candles
barcolor(paintCandles ? col : na, title = "Trend Candles")

// Alert Conditions
alertcondition(long, title="Kalman Hull Kijun Long", message="Kalman Hull Kijun Long {{exchange}}:{{ticker}}")
alertcondition(short, title="Kalman Hull Kijun Short", message="Kalman Hull Kijun Short {{exchange}}:{{ticker}}")