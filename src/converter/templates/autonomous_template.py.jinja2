{# src/converter/templates/autonomous_template.py.jinja2 #}
"""
{{ metadata.strategy_name }} (Autonomous)

Generated by: {{ metadata.source }}
Generated at: {{ metadata.generated_at }}
Original Pine Version: v{{ metadata.original_pine_version }}

Analysis Summary:
- Total Score: {{ metadata.analysis_summary.total_score }}
- Grade: {{ metadata.analysis_summary.grade }}
- Repainting Risk: {{ metadata.analysis_summary.repainting_risk }}

Autonomous Features:
- Self-optimizing parameters
- Performance tracking
- Automatic regime adaptation
- Dynamic position sizing
"""

import numpy as np
from typing import List, Dict, Optional, Any
from datetime import datetime
from collections import deque


{{ pine_code_comment }}


class {{ class_name }}:
    """{{ metadata.strategy_name }} - Autonomous Version"""

    def __init__(self, params: Dict = None, user_id: int = None):
        self.params = params or {}
        self.user_id = user_id
        self.strategy_code = "{{ metadata.strategy_code }}"

        # Dynamic parameters (self-adjusting)
        self._dynamic_params = {
            "ema_fast": self.params.get("ema_fast", 9),
            "ema_slow": self.params.get("ema_slow", 21),
            "rsi_period": self.params.get("rsi_period", 14),
            "rsi_oversold": self.params.get("rsi_oversold", 30),
            "rsi_overbought": self.params.get("rsi_overbought", 70),
        }

        # Risk parameters
        self.base_risk_per_trade = self.params.get("risk_per_trade", 1.0)
        self.max_drawdown_limit = self.params.get("max_drawdown", 10.0)

        # Performance tracking
        self._trade_history = deque(maxlen=100)
        self._win_rate = 0.5
        self._avg_win = 2.0
        self._avg_loss = 1.0
        self._current_drawdown = 0.0

        # State
        self._last_optimization = datetime.now()
        self._optimization_interval_hours = 24

    def generate_signal(
        self,
        current_price: float,
        candles: List[Dict],
        current_position: Optional[Dict] = None
    ) -> Dict:
        """Generate autonomous trading signal"""

        if len(candles) < 200:
            return self._hold("Insufficient data")

        # Periodic self-optimization
        self._maybe_optimize()

        # Check risk limits
        if self._current_drawdown >= self.max_drawdown_limit:
            return self._hold(f"Max drawdown reached: {self._current_drawdown:.1f}%")

        # Extract data
        closes = np.array([c["close"] for c in candles])
        highs = np.array([c["high"] for c in candles])
        lows = np.array([c["low"] for c in candles])

        # Check exit
        if current_position:
            exit_signal = self._autonomous_exit(current_position, closes, highs, lows)
            if exit_signal:
                return exit_signal

        # Entry with dynamic sizing
        if not current_position:
            return self._autonomous_entry(closes, highs, lows, current_price)

        return self._hold("Waiting")

    def _autonomous_entry(
        self,
        closes: np.ndarray,
        highs: np.ndarray,
        lows: np.ndarray,
        current_price: float
    ) -> Dict:
        """Generate entry signal with autonomous logic"""

        # Get dynamic parameters
        ema_fast_period = self._dynamic_params["ema_fast"]
        ema_slow_period = self._dynamic_params["ema_slow"]
        rsi_period = self._dynamic_params["rsi_period"]
        rsi_oversold = self._dynamic_params["rsi_oversold"]
        rsi_overbought = self._dynamic_params["rsi_overbought"]

        # Calculate indicators
        ema_fast = self._ema(closes, ema_fast_period)
        ema_slow = self._ema(closes, ema_slow_period)
        rsi = self._rsi(closes, rsi_period)
        atr = self._atr(highs, lows, closes, 14)

        # Trend and momentum analysis
        trend = "up" if ema_fast > ema_slow else "down"
        momentum = "oversold" if rsi < rsi_oversold else "overbought" if rsi > rsi_overbought else "neutral"

        # Calculate position size based on performance
        position_size = self._calculate_position_size(atr, current_price)

        # Entry logic
        confidence = 0.5

        if trend == "up" and momentum == "oversold":
            confidence = self._calculate_confidence("long", closes, rsi)
            if confidence >= 0.6:
                return {
                    "action": "buy",
                    "confidence": confidence,
                    "reason": f"Uptrend + RSI oversold ({rsi:.0f})",
                    "position_size_percent": position_size,
                    "stop_loss": self._calculate_dynamic_sl(highs, lows, "long"),
                    "take_profit": self._calculate_dynamic_tp(highs, lows, "long"),
                    "strategy_type": self.strategy_code,
                    "autonomous": True
                }

        elif trend == "down" and momentum == "overbought":
            confidence = self._calculate_confidence("short", closes, rsi)
            if confidence >= 0.6:
                return {
                    "action": "sell",
                    "confidence": confidence,
                    "reason": f"Downtrend + RSI overbought ({rsi:.0f})",
                    "position_size_percent": position_size,
                    "stop_loss": self._calculate_dynamic_sl(highs, lows, "short"),
                    "take_profit": self._calculate_dynamic_tp(highs, lows, "short"),
                    "strategy_type": self.strategy_code,
                    "autonomous": True
                }

        return self._hold("No high-probability setup")

    def _autonomous_exit(
        self,
        position: Dict,
        closes: np.ndarray,
        highs: np.ndarray,
        lows: np.ndarray
    ) -> Optional[Dict]:
        """Autonomous exit logic"""
        pnl_pct = position.get("pnl_percent", 0)
        entry_time = position.get("entry_time")
        side = position.get("side", "long")

        # Dynamic SL/TP based on current volatility
        atr = self._atr(highs, lows, closes, 14)
        atr_pct = (atr / closes[-1]) * 100

        dynamic_sl = max(1.5, atr_pct * 2)
        dynamic_tp = max(3.0, atr_pct * 4)

        # Stop loss
        if pnl_pct <= -dynamic_sl:
            self._record_trade(pnl_pct)
            return self._close(f"Dynamic SL: {pnl_pct:.2f}%", 0.95)

        # Take profit
        if pnl_pct >= dynamic_tp:
            self._record_trade(pnl_pct)
            return self._close(f"Dynamic TP: {pnl_pct:.2f}%", 0.9)

        # Trend reversal exit
        ema_fast = self._ema(closes, self._dynamic_params["ema_fast"])
        ema_slow = self._ema(closes, self._dynamic_params["ema_slow"])

        if side == "long" and ema_fast < ema_slow and pnl_pct > 0:
            self._record_trade(pnl_pct)
            return self._close("Trend reversal (profit lock)", 0.8)

        if side == "short" and ema_fast > ema_slow and pnl_pct > 0:
            self._record_trade(pnl_pct)
            return self._close("Trend reversal (profit lock)", 0.8)

        # Trailing stop
        if pnl_pct > dynamic_tp * 0.5:
            max_pnl = position.get("max_pnl_percent", pnl_pct)
            if max_pnl - pnl_pct > dynamic_sl * 0.5:
                self._record_trade(pnl_pct)
                return self._close(f"Trailing: gave back {max_pnl - pnl_pct:.1f}%", 0.85)

        return None

    def _calculate_confidence(self, direction: str, closes: np.ndarray, rsi: float) -> float:
        """Calculate entry confidence based on multiple factors"""
        confidence = 0.5

        # Win rate factor
        if self._win_rate > 0.55:
            confidence += 0.1
        elif self._win_rate < 0.4:
            confidence -= 0.1

        # Risk/reward factor
        if self._avg_win > self._avg_loss * 1.5:
            confidence += 0.1

        # RSI extreme factor
        if direction == "long" and rsi < 25:
            confidence += 0.1
        elif direction == "short" and rsi > 75:
            confidence += 0.1

        # Trend strength
        ema_fast = self._ema(closes, self._dynamic_params["ema_fast"])
        ema_slow = self._ema(closes, self._dynamic_params["ema_slow"])
        trend_strength = abs(ema_fast - ema_slow) / ema_slow

        if trend_strength > 0.02:
            confidence += 0.05

        return min(confidence, 0.95)

    def _calculate_position_size(self, atr: float, current_price: float) -> float:
        """Calculate position size based on volatility and performance"""
        base_size = self.base_risk_per_trade

        # Reduce size during drawdown
        if self._current_drawdown > 5:
            base_size *= 0.5
        elif self._current_drawdown > 2:
            base_size *= 0.75

        # Increase size with good win rate
        if self._win_rate > 0.6 and len(self._trade_history) > 20:
            base_size *= 1.25

        # Volatility adjustment
        atr_pct = (atr / current_price) * 100
        if atr_pct > 2:
            base_size *= 0.7

        return round(min(base_size, 5.0), 2)

    def _calculate_dynamic_sl(self, highs: np.ndarray, lows: np.ndarray, direction: str) -> float:
        """Calculate dynamic stop loss"""
        recent_range = np.mean(highs[-10:] - lows[-10:])
        price = (highs[-1] + lows[-1]) / 2
        sl_pct = (recent_range * 1.5 / price) * 100
        return round(max(1.0, min(sl_pct, 5.0)), 2)

    def _calculate_dynamic_tp(self, highs: np.ndarray, lows: np.ndarray, direction: str) -> float:
        """Calculate dynamic take profit"""
        sl = self._calculate_dynamic_sl(highs, lows, direction)
        return round(sl * 2, 2)

    def _record_trade(self, pnl_pct: float):
        """Record trade for performance tracking"""
        self._trade_history.append(pnl_pct)
        self._update_stats()

    def _update_stats(self):
        """Update performance statistics"""
        if len(self._trade_history) < 5:
            return

        trades = list(self._trade_history)
        wins = [t for t in trades if t > 0]
        losses = [t for t in trades if t < 0]

        self._win_rate = len(wins) / len(trades) if trades else 0.5
        self._avg_win = np.mean(wins) if wins else 2.0
        self._avg_loss = abs(np.mean(losses)) if losses else 1.0

        # Update drawdown
        cumsum = np.cumsum(trades)
        running_max = np.maximum.accumulate(cumsum)
        drawdown = running_max - cumsum
        self._current_drawdown = max(drawdown) if len(drawdown) > 0 else 0

    def _maybe_optimize(self):
        """Periodically optimize parameters"""
        hours_since = (datetime.now() - self._last_optimization).total_seconds() / 3600

        if hours_since < self._optimization_interval_hours:
            return

        if len(self._trade_history) < 20:
            return

        # Simple optimization based on performance
        if self._win_rate < 0.4:
            # Make more conservative
            self._dynamic_params["rsi_oversold"] = max(20, self._dynamic_params["rsi_oversold"] - 5)
            self._dynamic_params["rsi_overbought"] = min(80, self._dynamic_params["rsi_overbought"] + 5)

        elif self._win_rate > 0.6:
            # Can be slightly more aggressive
            self._dynamic_params["rsi_oversold"] = min(35, self._dynamic_params["rsi_oversold"] + 2)
            self._dynamic_params["rsi_overbought"] = max(65, self._dynamic_params["rsi_overbought"] - 2)

        self._last_optimization = datetime.now()

    def _close(self, reason: str, confidence: float) -> Dict:
        return {
            "action": "close",
            "confidence": confidence,
            "reason": reason,
            "strategy_type": self.strategy_code,
            "autonomous": True
        }

    def _hold(self, reason: str) -> Dict:
        return {
            "action": "hold",
            "confidence": 0.5,
            "reason": reason,
            "strategy_type": self.strategy_code,
            "autonomous": True
        }

    def _ema(self, data: np.ndarray, period: int) -> float:
        if len(data) < period:
            return data[-1]
        multiplier = 2 / (period + 1)
        ema = data[0]
        for price in data[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        return ema

    def _rsi(self, data: np.ndarray, period: int = 14) -> float:
        if len(data) < period + 1:
            return 50.0
        deltas = np.diff(data[-period-1:])
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        avg_gain = np.mean(gains)
        avg_loss = np.mean(losses)
        if avg_loss == 0:
            return 100.0
        return 100 - (100 / (1 + avg_gain / avg_loss))

    def _atr(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray, period: int = 14) -> float:
        if len(closes) < period + 1:
            return highs[-1] - lows[-1]
        tr = np.maximum(
            highs[-period:] - lows[-period:],
            np.maximum(
                np.abs(highs[-period:] - closes[-period-1:-1]),
                np.abs(lows[-period:] - closes[-period-1:-1])
            )
        )
        return np.mean(tr)

    def get_stats(self) -> Dict:
        """Get current performance stats"""
        return {
            "win_rate": self._win_rate,
            "avg_win": self._avg_win,
            "avg_loss": self._avg_loss,
            "current_drawdown": self._current_drawdown,
            "total_trades": len(self._trade_history),
            "dynamic_params": self._dynamic_params
        }


def generate_signal(
    current_price: float,
    candles: List[Dict],
    params: Dict = None,
    current_position: Optional[Dict] = None
) -> Dict:
    strategy = {{ class_name }}(params)
    return strategy.generate_signal(current_price, candles, current_position)
