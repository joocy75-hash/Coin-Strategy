{# src/converter/templates/basic_template.py.jinja2 #}
"""
{{ metadata.strategy_name }}

Generated by: {{ metadata.source }}
Generated at: {{ metadata.generated_at }}
Original Pine Version: v{{ metadata.original_pine_version }}

Analysis Summary:
- Total Score: {{ metadata.analysis_summary.total_score }}
- Grade: {{ metadata.analysis_summary.grade }}
- Repainting Risk: {{ metadata.analysis_summary.repainting_risk }}
"""

import numpy as np
from typing import List, Dict, Optional


{{ pine_code_comment }}


class {{ class_name }}:
    """{{ metadata.strategy_name }}"""

    def __init__(self, params: Dict = None, user_id: int = None):
        self.params = params or {}
        self.user_id = user_id
        self.strategy_code = "{{ metadata.strategy_code }}"

        # Parameters with defaults
        self.ema_fast = self.params.get("ema_fast", 9)
        self.ema_slow = self.params.get("ema_slow", 21)
        self.rsi_period = self.params.get("rsi_period", 14)
        self.stop_loss_pct = self.params.get("stop_loss_percent", 2.0)
        self.take_profit_pct = self.params.get("take_profit_percent", 4.0)
        self.leverage = self.params.get("leverage", 5)

    def generate_signal(
        self,
        current_price: float,
        candles: List[Dict],
        current_position: Optional[Dict] = None
    ) -> Dict:
        """
        Generate trading signal

        Args:
            current_price: Current price
            candles: OHLCV candle data
            current_position: Current position (None if no position)

        Returns:
            Signal dictionary
        """

        # Check exit conditions first
        if current_position:
            exit_signal = self._check_exit(current_position, current_price)
            if exit_signal:
                return exit_signal

        # Entry logic
        if not current_position:
{{ logic_code | indent(12) }}

        # Default response
        return {
            "action": "hold",
            "confidence": 0.5,
            "reason": "No signal",
            "strategy_type": self.strategy_code,
            "ai_powered": False
        }

    def _check_exit(self, position: Dict, current_price: float) -> Optional[Dict]:
        """Check position exit conditions"""
        pnl_pct = position.get('pnl_percent', 0)

        # Take profit
        if pnl_pct >= self.take_profit_pct:
            return {
                "action": "close",
                "confidence": 0.9,
                "reason": f"Take Profit: {pnl_pct:.2f}%",
                "strategy_type": self.strategy_code
            }

        # Stop loss
        if pnl_pct <= -self.stop_loss_pct:
            return {
                "action": "close",
                "confidence": 0.95,
                "reason": f"Stop Loss: {pnl_pct:.2f}%",
                "strategy_type": self.strategy_code
            }

        return None

    def _calculate_ema(self, prices: List[float], period: int) -> float:
        """Calculate Exponential Moving Average"""
        if len(prices) < period:
            return prices[-1] if prices else 0

        multiplier = 2 / (period + 1)
        ema = prices[0]
        for price in prices[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        return ema

    def _calculate_rsi(self, prices: List[float], period: int = 14) -> float:
        """Calculate RSI"""
        if len(prices) < period + 1:
            return 50.0

        deltas = np.diff(prices[-period-1:])
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        avg_gain = np.mean(gains)
        avg_loss = np.mean(losses)

        if avg_loss == 0:
            return 100.0

        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))


# Function interface for compatibility
def generate_signal(
    current_price: float,
    candles: List[Dict],
    params: Dict = None,
    current_position: Optional[Dict] = None
) -> Dict:
    """Function wrapper"""
    strategy = {{ class_name }}(params)
    return strategy.generate_signal(current_price, candles, current_position)
