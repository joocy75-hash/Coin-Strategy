{# src/converter/templates/ai_template.py.jinja2 #}
"""
{{ metadata.strategy_name }} (AI-Enhanced)

Generated by: {{ metadata.source }}
Generated at: {{ metadata.generated_at }}
Original Pine Version: v{{ metadata.original_pine_version }}

Analysis Summary:
- Total Score: {{ metadata.analysis_summary.total_score }}
- Grade: {{ metadata.analysis_summary.grade }}
- Repainting Risk: {{ metadata.analysis_summary.repainting_risk }}

AI Features:
- Market regime detection
- Adaptive parameters
- Confidence-based position sizing
"""

import numpy as np
from typing import List, Dict, Optional
from datetime import datetime


{{ pine_code_comment }}


class {{ class_name }}:
    """{{ metadata.strategy_name }} - AI Enhanced Version"""

    def __init__(self, params: Dict = None, user_id: int = None):
        self.params = params or {}
        self.user_id = user_id
        self.strategy_code = "{{ metadata.strategy_code }}"

        # Base parameters
        self.ema_fast = self.params.get("ema_fast", 9)
        self.ema_slow = self.params.get("ema_slow", 21)
        self.rsi_period = self.params.get("rsi_period", 14)
        self.atr_period = self.params.get("atr_period", 14)

        # Risk parameters
        self.base_stop_loss = self.params.get("stop_loss_percent", 2.0)
        self.base_take_profit = self.params.get("take_profit_percent", 4.0)
        self.max_position_pct = self.params.get("max_position_percent", 10.0)

        # AI parameters
        self.confidence_threshold = self.params.get("confidence_threshold", 0.6)
        self.adaptive_enabled = self.params.get("adaptive_enabled", True)

        # State
        self._market_regime = "neutral"
        self._volatility_state = "normal"

    def generate_signal(
        self,
        current_price: float,
        candles: List[Dict],
        current_position: Optional[Dict] = None
    ) -> Dict:
        """Generate AI-enhanced trading signal"""

        if len(candles) < 100:
            return self._hold("Insufficient data for AI analysis")

        # Extract data
        closes = np.array([c["close"] for c in candles])
        highs = np.array([c["high"] for c in candles])
        lows = np.array([c["low"] for c in candles])
        volumes = np.array([c.get("volume", 0) for c in candles])

        # Market analysis
        self._analyze_market_regime(closes)
        self._analyze_volatility(highs, lows, closes)

        # Adaptive parameters
        stop_loss, take_profit = self._calculate_adaptive_sl_tp(highs, lows, closes)

        # Check exit first
        if current_position:
            exit_signal = self._check_smart_exit(current_position, current_price, closes)
            if exit_signal:
                return exit_signal

        # Entry logic with confidence scoring
        if not current_position:
            signal = self._generate_entry_signal(closes, highs, lows, volumes)

            if signal["action"] != "hold" and signal["confidence"] >= self.confidence_threshold:
                signal["stop_loss"] = stop_loss
                signal["take_profit"] = take_profit
                signal["market_regime"] = self._market_regime
                signal["volatility"] = self._volatility_state
                return signal

        return self._hold("No high-confidence signal")

    def _analyze_market_regime(self, closes: np.ndarray):
        """Detect market regime (trending/ranging)"""
        # Simple regime detection using EMA slope
        ema_50 = self._ema(closes, 50)
        ema_200 = self._ema(closes, 200)

        if len(closes) < 200:
            self._market_regime = "neutral"
            return

        slope_50 = (ema_50 - self._ema(closes[:-20], 50)) / ema_50
        price_vs_ema = (closes[-1] - ema_200) / ema_200

        if slope_50 > 0.02 and price_vs_ema > 0.05:
            self._market_regime = "bullish"
        elif slope_50 < -0.02 and price_vs_ema < -0.05:
            self._market_regime = "bearish"
        else:
            self._market_regime = "ranging"

    def _analyze_volatility(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray):
        """Analyze market volatility"""
        current_atr = self._atr(highs, lows, closes, self.atr_period)
        avg_atr = self._atr(highs[:-20], lows[:-20], closes[:-20], self.atr_period)

        if avg_atr == 0:
            self._volatility_state = "normal"
            return

        ratio = current_atr / avg_atr

        if ratio > 1.5:
            self._volatility_state = "high"
        elif ratio < 0.7:
            self._volatility_state = "low"
        else:
            self._volatility_state = "normal"

    def _calculate_adaptive_sl_tp(
        self,
        highs: np.ndarray,
        lows: np.ndarray,
        closes: np.ndarray
    ) -> tuple:
        """Calculate adaptive stop loss and take profit"""
        if not self.adaptive_enabled:
            return self.base_stop_loss, self.base_take_profit

        atr = self._atr(highs, lows, closes, self.atr_period)
        atr_pct = (atr / closes[-1]) * 100

        # Adjust based on volatility
        if self._volatility_state == "high":
            multiplier = 1.5
        elif self._volatility_state == "low":
            multiplier = 0.7
        else:
            multiplier = 1.0

        stop_loss = max(self.base_stop_loss, atr_pct * 2 * multiplier)
        take_profit = max(self.base_take_profit, atr_pct * 4 * multiplier)

        return round(stop_loss, 2), round(take_profit, 2)

    def _generate_entry_signal(
        self,
        closes: np.ndarray,
        highs: np.ndarray,
        lows: np.ndarray,
        volumes: np.ndarray
    ) -> Dict:
        """Generate entry signal with confidence"""
        # Calculate indicators
        ema_fast = self._ema(closes, self.ema_fast)
        ema_slow = self._ema(closes, self.ema_slow)
        rsi = self._rsi(closes, self.rsi_period)

        # Volume analysis
        vol_sma = np.mean(volumes[-20:])
        vol_ratio = volumes[-1] / vol_sma if vol_sma > 0 else 1

        # Build confidence score
        confidence = 0.5
        reasons = []

        # Trend alignment
        if ema_fast > ema_slow:
            trend_signal = "long"
            if self._market_regime == "bullish":
                confidence += 0.15
                reasons.append("Bullish regime")
        else:
            trend_signal = "short"
            if self._market_regime == "bearish":
                confidence += 0.15
                reasons.append("Bearish regime")

        # RSI confirmation
        if trend_signal == "long" and 30 < rsi < 60:
            confidence += 0.1
            reasons.append(f"RSI ok ({rsi:.0f})")
        elif trend_signal == "short" and 40 < rsi < 70:
            confidence += 0.1
            reasons.append(f"RSI ok ({rsi:.0f})")

        # Volume confirmation
        if vol_ratio > 1.2:
            confidence += 0.1
            reasons.append("High volume")

        # Volatility filter
        if self._volatility_state == "normal":
            confidence += 0.05

        action = "buy" if trend_signal == "long" else "sell"

        return {
            "action": action,
            "confidence": min(confidence, 0.95),
            "reason": ", ".join(reasons) if reasons else "Technical signal",
            "strategy_type": self.strategy_code,
            "ai_powered": True
        }

    def _check_smart_exit(
        self,
        position: Dict,
        current_price: float,
        closes: np.ndarray
    ) -> Optional[Dict]:
        """Smart exit with trailing and regime awareness"""
        pnl_pct = position.get("pnl_percent", 0)
        side = position.get("side", "long")

        # Basic SL/TP
        if pnl_pct <= -self.base_stop_loss:
            return self._close("Stop Loss hit", 0.95)

        if pnl_pct >= self.base_take_profit:
            return self._close("Take Profit hit", 0.9)

        # Trailing stop for profitable positions
        if pnl_pct > self.base_stop_loss:
            trailing_stop = pnl_pct - self.base_stop_loss
            max_pnl = position.get("max_pnl_percent", pnl_pct)

            if max_pnl - pnl_pct > trailing_stop:
                return self._close(f"Trailing stop: gave back {max_pnl - pnl_pct:.1f}%", 0.85)

        # Regime change exit
        if side == "long" and self._market_regime == "bearish" and pnl_pct > 0:
            return self._close("Regime changed to bearish", 0.7)
        elif side == "short" and self._market_regime == "bullish" and pnl_pct > 0:
            return self._close("Regime changed to bullish", 0.7)

        return None

    def _close(self, reason: str, confidence: float) -> Dict:
        return {
            "action": "close",
            "confidence": confidence,
            "reason": reason,
            "strategy_type": self.strategy_code
        }

    def _hold(self, reason: str) -> Dict:
        return {
            "action": "hold",
            "confidence": 0.5,
            "reason": reason,
            "strategy_type": self.strategy_code,
            "ai_powered": True
        }

    def _ema(self, data: np.ndarray, period: int) -> float:
        if len(data) < period:
            return data[-1]
        multiplier = 2 / (period + 1)
        ema = data[0]
        for price in data[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        return ema

    def _rsi(self, data: np.ndarray, period: int = 14) -> float:
        if len(data) < period + 1:
            return 50.0
        deltas = np.diff(data[-period-1:])
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        avg_gain = np.mean(gains)
        avg_loss = np.mean(losses)
        if avg_loss == 0:
            return 100.0
        return 100 - (100 / (1 + avg_gain / avg_loss))

    def _atr(self, highs: np.ndarray, lows: np.ndarray, closes: np.ndarray, period: int = 14) -> float:
        if len(closes) < period + 1:
            return highs[-1] - lows[-1]
        tr = np.maximum(
            highs[-period:] - lows[-period:],
            np.maximum(
                np.abs(highs[-period:] - closes[-period-1:-1]),
                np.abs(lows[-period:] - closes[-period-1:-1])
            )
        )
        return np.mean(tr)


def generate_signal(
    current_price: float,
    candles: List[Dict],
    params: Dict = None,
    current_position: Optional[Dict] = None
) -> Dict:
    strategy = {{ class_name }}(params)
    return strategy.generate_signal(current_price, candles, current_position)
