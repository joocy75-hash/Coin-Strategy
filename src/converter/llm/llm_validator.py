"""
LLM Code Validator

Validates Python code generated by LLM for correctness,
completeness, and adherence to backtesting.py conventions.
"""

import ast
import re
import logging
from dataclasses import dataclass, field
from typing import List, Optional, Set
from enum import Enum

from ..pine_parser import PineAST

logger = logging.getLogger(__name__)


# ============================================================================
# Validation Models
# ============================================================================

class ValidationLevel(Enum):
    """Validation severity levels"""
    ERROR = "error"        # Must fix (code won't run)
    WARNING = "warning"    # Should fix (code may not work as expected)
    INFO = "info"          # Nice to have (optimization suggestions)


@dataclass
class ValidationIssue:
    """Single validation issue"""
    level: ValidationLevel
    message: str
    line_number: Optional[int] = None
    suggestion: Optional[str] = None


@dataclass
class LLMValidationResult:
    """Complete validation result"""
    is_valid: bool
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    info: List[str] = field(default_factory=list)
    issues: List[ValidationIssue] = field(default_factory=list)


# ============================================================================
# Validator
# ============================================================================

class LLMValidator:
    """
    Validate LLM-generated Python strategy code.

    Validation checks:
    1. Python syntax (AST parsing)
    2. Required methods (init, next)
    3. Strategy class structure
    4. Indicator usage patterns
    5. backtesting.py conventions
    6. Parameter preservation from Pine Script

    Example:
        >>> validator = LLMValidator()
        >>> result = validator.validate(python_code, ast)
        >>> if not result.is_valid:
        ...     print(result.errors)
    """

    # Required imports for backtesting
    REQUIRED_IMPORTS = {
        "backtesting": ["Strategy"],
    }

    # backtesting.py methods
    STRATEGY_METHODS = {
        "init": "Initialize indicators (called once)",
        "next": "Execute strategy logic (called per bar)",
    }

    def __init__(self):
        """Initialize validator"""
        logger.debug("Initialized LLMValidator")

    def validate(
        self,
        python_code: str,
        original_ast: PineAST,
    ) -> LLMValidationResult:
        """
        Validate generated Python code against original Pine Script.

        Args:
            python_code: Generated Python code
            original_ast: Original Pine Script AST

        Returns:
            LLMValidationResult with all validation findings

        Example:
            >>> result = validator.validate(code, ast)
            >>> result.is_valid
            True
        """
        logger.debug(f"Validating code for '{original_ast.script_name}'")

        issues: List[ValidationIssue] = []

        # 1. Python syntax validation
        issues.extend(self._validate_syntax(python_code))

        # 2. Imports validation
        issues.extend(self._validate_imports(python_code))

        # 3. Class structure validation
        issues.extend(self._validate_class_structure(python_code))

        # 4. Required methods validation
        issues.extend(self._validate_methods(python_code))

        # 5. Indicator usage validation
        issues.extend(self._validate_indicators(python_code, original_ast))

        # 6. Parameter preservation validation
        issues.extend(self._validate_parameters(python_code, original_ast))

        # 7. backtesting.py conventions
        issues.extend(self._validate_backtest_conventions(python_code))

        # Separate by level
        errors = [
            issue.message for issue in issues
            if issue.level == ValidationLevel.ERROR
        ]
        warnings = [
            issue.message for issue in issues
            if issue.level == ValidationLevel.WARNING
        ]
        info = [
            issue.message for issue in issues
            if issue.level == ValidationLevel.INFO
        ]

        is_valid = len(errors) == 0

        logger.debug(
            f"Validation {'passed' if is_valid else 'failed'}: "
            f"{len(errors)} errors, {len(warnings)} warnings"
        )

        return LLMValidationResult(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings,
            info=info,
            issues=issues,
        )

    # ------------------------------------------------------------------------
    # Validation Checks
    # ------------------------------------------------------------------------

    def _validate_syntax(self, code: str) -> List[ValidationIssue]:
        """Validate Python syntax"""
        issues = []

        try:
            ast.parse(code)
        except SyntaxError as e:
            issues.append(ValidationIssue(
                level=ValidationLevel.ERROR,
                message=f"Python syntax error: {e.msg}",
                line_number=e.lineno,
                suggestion="Fix syntax error before proceeding"
            ))

        return issues

    def _validate_imports(self, code: str) -> List[ValidationIssue]:
        """Validate required imports"""
        issues = []

        # Check for Strategy import
        if 'from backtesting import Strategy' not in code:
            issues.append(ValidationIssue(
                level=ValidationLevel.ERROR,
                message="Missing required import: from backtesting import Strategy",
                suggestion="Add: from backtesting import Strategy"
            ))

        # Check for pandas-ta (recommended)
        if 'import pandas_ta' not in code and 'ta.' in code:
            issues.append(ValidationIssue(
                level=ValidationLevel.WARNING,
                message="Missing pandas_ta import but indicators used",
                suggestion="Add: import pandas_ta as ta"
            ))

        return issues

    def _validate_class_structure(self, code: str) -> List[ValidationIssue]:
        """Validate Strategy class structure"""
        issues = []

        # Check for class definition
        class_match = re.search(r'class\s+(\w+)\s*\(\s*Strategy\s*\)', code)

        if not class_match:
            issues.append(ValidationIssue(
                level=ValidationLevel.ERROR,
                message="No Strategy class found or incorrect inheritance",
                suggestion="Define: class YourStrategy(Strategy):"
            ))

        return issues

    def _validate_methods(self, code: str) -> List[ValidationIssue]:
        """Validate required methods"""
        issues = []

        for method_name, description in self.STRATEGY_METHODS.items():
            if f'def {method_name}(self' not in code:
                issues.append(ValidationIssue(
                    level=ValidationLevel.ERROR,
                    message=f"Missing required method: {method_name}()",
                    suggestion=f"Add: def {method_name}(self): # {description}"
                ))

        return issues

    def _validate_indicators(
        self,
        code: str,
        ast: PineAST
    ) -> List[ValidationIssue]:
        """Validate indicator usage"""
        issues = []

        # Check for self.I() wrapper usage
        if 'ta.' in code and 'self.I(' not in code:
            issues.append(ValidationIssue(
                level=ValidationLevel.WARNING,
                message="Indicators used but not wrapped with self.I()",
                suggestion="Use: self.indicator = self.I(ta.function, ...)"
            ))

        # Check if all Pine indicators are mapped
        for indicator in ast.indicators_used:
            indicator_name = indicator.replace('ta.', '')
            if indicator_name not in code.lower():
                issues.append(ValidationIssue(
                    level=ValidationLevel.WARNING,
                    message=f"Pine Script indicator '{indicator}' not found in Python code",
                    suggestion=f"Ensure {indicator} is implemented"
                ))

        return issues

    def _validate_parameters(
        self,
        code: str,
        ast: PineAST
    ) -> List[ValidationIssue]:
        """Validate parameter preservation from Pine Script"""
        issues = []

        # Check that Pine inputs are preserved as class attributes
        for input_node in ast.inputs:
            if input_node.name not in code:
                issues.append(ValidationIssue(
                    level=ValidationLevel.WARNING,
                    message=f"Pine Script input '{input_node.name}' not found in Python code",
                    suggestion=f"Add class attribute: {input_node.name} = {input_node.default_value}"
                ))

        return issues

    def _validate_backtest_conventions(self, code: str) -> List[ValidationIssue]:
        """Validate backtesting.py specific conventions"""
        issues = []

        # Check for proper data access
        if '.Close' in code and 'self.data.Close' not in code:
            issues.append(ValidationIssue(
                level=ValidationLevel.INFO,
                message="Use self.data.Close instead of .Close for price data",
                suggestion="Replace .Close with self.data.Close"
            ))

        # Check for buy/sell calls
        if 'strategy.entry' in code.lower() or 'strategy.close' in code.lower():
            issues.append(ValidationIssue(
                level=ValidationLevel.WARNING,
                message="Pine Script strategy calls found - convert to self.buy()/self.sell()",
                suggestion="Use: self.buy() for longs, self.sell() for shorts"
            ))

        # Check for position access
        if 'self.position' not in code and ('self.buy()' in code or 'self.sell()' in code):
            issues.append(ValidationIssue(
                level=ValidationLevel.INFO,
                message="Consider checking self.position before trades",
                suggestion="if not self.position: self.buy()"
            ))

        return issues
