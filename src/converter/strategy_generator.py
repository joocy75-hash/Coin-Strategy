# src/converter/strategy_generator.py

import os
import re
from typing import Dict, Optional
from datetime import datetime
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, BaseLoader
import logging

logger = logging.getLogger(__name__)


# 기본 템플릿 (파일이 없을 경우 사용)
DEFAULT_BASIC_TEMPLATE = '''"""
{{ metadata.strategy_name }}

Generated by: {{ metadata.source }}
Generated at: {{ metadata.generated_at }}
Original Pine Version: v{{ metadata.original_pine_version }}

Analysis Summary:
- Total Score: {{ metadata.analysis_summary.total_score }}
- Grade: {{ metadata.analysis_summary.grade }}
- Repainting Risk: {{ metadata.analysis_summary.repainting_risk }}
"""

import numpy as np
from typing import List, Dict, Optional


{{ pine_code_comment }}


class {{ class_name }}:
    """{{ metadata.strategy_name }}"""

    def __init__(self, params: Dict = None, user_id: int = None):
        self.params = params or {}
        self.user_id = user_id
        self.strategy_code = "{{ metadata.strategy_code }}"

        # Parameters with defaults
        self.ema_fast = self.params.get("ema_fast", 9)
        self.ema_slow = self.params.get("ema_slow", 21)
        self.rsi_period = self.params.get("rsi_period", 14)
        self.stop_loss_pct = self.params.get("stop_loss_percent", 2.0)
        self.take_profit_pct = self.params.get("take_profit_percent", 4.0)
        self.leverage = self.params.get("leverage", 5)

    def generate_signal(
        self,
        current_price: float,
        candles: List[Dict],
        current_position: Optional[Dict] = None
    ) -> Dict:
        """
        Generate trading signal

        Args:
            current_price: Current price
            candles: OHLCV candle data
            current_position: Current position (None if no position)

        Returns:
            Signal dictionary
        """

        # Check exit conditions first
        if current_position:
            exit_signal = self._check_exit(current_position, current_price)
            if exit_signal:
                return exit_signal

        # Entry logic
        if not current_position:
{{ logic_code | indent(12) }}

        # Default response
        return {
            "action": "hold",
            "confidence": 0.5,
            "reason": "No signal",
            "strategy_type": self.strategy_code,
            "ai_powered": False
        }

    def _check_exit(self, position: Dict, current_price: float) -> Optional[Dict]:
        """Check position exit conditions"""
        pnl_pct = position.get('pnl_percent', 0)

        # Take profit
        if pnl_pct >= self.take_profit_pct:
            return {
                "action": "close",
                "confidence": 0.9,
                "reason": f"Take Profit: {pnl_pct:.2f}%",
                "strategy_type": self.strategy_code
            }

        # Stop loss
        if pnl_pct <= -self.stop_loss_pct:
            return {
                "action": "close",
                "confidence": 0.95,
                "reason": f"Stop Loss: {pnl_pct:.2f}%",
                "strategy_type": self.strategy_code
            }

        return None

    def _calculate_ema(self, prices: List[float], period: int) -> float:
        """Calculate Exponential Moving Average"""
        if len(prices) < period:
            return prices[-1] if prices else 0

        multiplier = 2 / (period + 1)
        ema = prices[0]
        for price in prices[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        return ema

    def _calculate_rsi(self, prices: List[float], period: int = 14) -> float:
        """Calculate RSI"""
        if len(prices) < period + 1:
            return 50.0

        deltas = np.diff(prices[-period-1:])
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        avg_gain = np.mean(gains)
        avg_loss = np.mean(losses)

        if avg_loss == 0:
            return 100.0

        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))


# Function interface for compatibility
def generate_signal(
    current_price: float,
    candles: List[Dict],
    params: Dict = None,
    current_position: Optional[Dict] = None
) -> Dict:
    """Function wrapper"""
    strategy = {{ class_name }}(params)
    return strategy.generate_signal(current_price, candles, current_position)
'''


class StrategyGenerator:
    """
    분석된 Pine Script를 플랫폼 호환 Python 전략으로 생성

    출력 파일 구조:
    - {strategy_code}_strategy.py (전략 파일)
    - 플랫폼 strategy_loader.py 등록 코드 스니펫
    """

    def __init__(self, templates_dir: str = None):
        if templates_dir and Path(templates_dir).exists():
            self.env = Environment(
                loader=FileSystemLoader(templates_dir),
                trim_blocks=True,
                lstrip_blocks=True
            )
            self.use_file_templates = True
        else:
            # 내장 템플릿 사용
            self.env = Environment(
                loader=BaseLoader(),
                trim_blocks=True,
                lstrip_blocks=True
            )
            self.use_file_templates = False

    def generate_strategy(
        self,
        strategy_code: str,
        strategy_name: str,
        strategy_type: str,  # basic, ai, autonomous
        pine_code: str,
        analysis_result: Dict,
        llm_converted_code: Optional[str] = None
    ) -> Dict[str, str]:
        """
        플랫폼 호환 전략 파일 생성

        Returns:
            {
                "strategy_file": "전략 Python 코드",
                "loader_snippet": "strategy_loader.py 등록 코드",
                "init_snippet": "__init__.py 등록 코드"
            }
        """

        # 전략 코드 정규화
        strategy_code = self._normalize_code(strategy_code)

        # 클래스명 생성
        class_name = self._generate_class_name(strategy_code)

        # 메타데이터 준비
        metadata = {
            "strategy_code": strategy_code,
            "strategy_name": strategy_name,
            "strategy_type": strategy_type,
            "generated_at": datetime.now().isoformat(),
            "source": "TradingView Strategy Research Lab",
            "original_pine_version": self._detect_pine_version(pine_code),
            "analysis_summary": {
                "total_score": analysis_result.get("total_score", 0),
                "grade": analysis_result.get("grade", "N/A"),
                "repainting_risk": analysis_result.get("repainting_analysis", {}).get("risk_level", "N/A"),
            }
        }

        # 전략 로직 추출/변환
        if llm_converted_code:
            logic_code = llm_converted_code
        else:
            logic_code = self._extract_basic_logic(pine_code)

        # Pine 코드 주석
        pine_code_comment = self._format_pine_as_comment(pine_code)

        # 템플릿 렌더링
        if self.use_file_templates:
            template_name = f"{strategy_type}_template.py.jinja2"
            try:
                template = self.env.get_template(template_name)
            except Exception:
                template = self.env.from_string(DEFAULT_BASIC_TEMPLATE)
        else:
            template = self.env.from_string(DEFAULT_BASIC_TEMPLATE)

        # 전략 파일 생성
        strategy_file = template.render(
            metadata=metadata,
            class_name=class_name,
            logic_code=logic_code,
            pine_code_comment=pine_code_comment,
            analysis=analysis_result
        )

        # Loader 등록 스니펫
        loader_snippet = self._generate_loader_snippet(strategy_code, class_name)

        # __init__.py 스니펫
        init_snippet = self._generate_init_snippet(strategy_code)

        return {
            "strategy_file": strategy_file,
            "loader_snippet": loader_snippet,
            "init_snippet": init_snippet,
            "filename": f"{strategy_code}_strategy.py",
            "class_name": class_name
        }

    def _normalize_code(self, code: str) -> str:
        """전략 코드 정규화 (파일명/변수명으로 사용 가능하게)"""
        # 소문자 + 언더스코어만
        normalized = re.sub(r'[^a-z0-9_]', '_', code.lower())
        # 연속 언더스코어 제거
        normalized = re.sub(r'_+', '_', normalized)
        # 앞뒤 언더스코어 제거
        normalized = normalized.strip('_')
        return normalized or "custom_strategy"

    def _generate_class_name(self, strategy_code: str) -> str:
        """클래스명 생성"""
        words = strategy_code.split('_')
        class_name = ''.join(word.capitalize() for word in words)
        return class_name + 'Strategy'

    def _detect_pine_version(self, code: str) -> int:
        """Pine Script 버전 감지"""
        match = re.search(r'//@version=(\d+)', code)
        return int(match.group(1)) if match else 5

    def _format_pine_as_comment(self, pine_code: str) -> str:
        """Pine 코드를 주석 형태로 변환"""
        if not pine_code:
            return ""

        lines = pine_code.split('\n')[:50]  # 상위 50줄만
        commented = '\n'.join(f"# {line}" for line in lines)

        return f'''
# ============================================================
# Original Pine Script (Reference Only)
# ============================================================
{commented}
# ... (truncated)
# ============================================================
'''

    def _extract_basic_logic(self, pine_code: str) -> str:
        """Pine Script에서 기본 로직 추출 (간단한 변환)"""
        logic = """
    # Basic indicator calculation
    closes = [c['close'] for c in candles]

    if len(closes) < 50:
        return {
            "action": "hold",
            "confidence": 0.0,
            "reason": "Insufficient data",
            "strategy_type": self.strategy_code
        }

    # EMA calculation
    ema_fast = self._calculate_ema(closes, self.ema_fast)
    ema_slow = self._calculate_ema(closes, self.ema_slow)

    # RSI calculation
    rsi = self._calculate_rsi(closes, self.rsi_period)

    # Signal generation logic
    if ema_fast > ema_slow and rsi < 70:
        return {
            "action": "buy",
            "confidence": 0.7,
            "reason": f"Bullish crossover (RSI: {rsi:.1f})",
            "stop_loss": self.stop_loss_pct,
            "take_profit": self.take_profit_pct,
            "strategy_type": self.strategy_code
        }
    elif ema_fast < ema_slow and rsi > 30:
        return {
            "action": "sell",
            "confidence": 0.7,
            "reason": f"Bearish crossover (RSI: {rsi:.1f})",
            "stop_loss": self.stop_loss_pct,
            "take_profit": self.take_profit_pct,
            "strategy_type": self.strategy_code
        }

    return {
        "action": "hold",
        "confidence": 0.5,
        "reason": "No clear signal",
        "strategy_type": self.strategy_code
    }
"""
        return logic

    def _generate_loader_snippet(self, strategy_code: str, class_name: str) -> str:
        """strategy_loader.py에 추가할 코드 스니펫"""
        return f'''
# === {strategy_code} ===
# Add to: strategy_loader.py -> _create_strategy_instance_internal function

elif strategy_code == "{strategy_code}":
    logger.info(f"Loading {strategy_code} for user {{user_id}}")
    from ..strategies.{strategy_code}_strategy import {class_name}
    return {class_name}(params, user_id=user_id)
'''

    def _generate_init_snippet(self, strategy_code: str) -> str:
        """__init__.py에 추가할 코드 스니펫"""
        return f'''
# Add to STRATEGY_CODES list in __init__.py:
"{strategy_code}",
'''

    def save_strategy(
        self,
        output_dir: str,
        strategy_code: str,
        strategy_name: str,
        strategy_type: str,
        pine_code: str,
        analysis_result: Dict,
        llm_converted_code: Optional[str] = None
    ) -> str:
        """전략 파일 저장"""
        result = self.generate_strategy(
            strategy_code=strategy_code,
            strategy_name=strategy_name,
            strategy_type=strategy_type,
            pine_code=pine_code,
            analysis_result=analysis_result,
            llm_converted_code=llm_converted_code
        )

        output_path = Path(output_dir) / result["filename"]
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(result["strategy_file"], encoding="utf-8")

        logger.info(f"Strategy saved: {output_path}")
        return str(output_path)
